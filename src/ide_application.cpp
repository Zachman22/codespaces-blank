#include "ide_application.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <algorithm>

namespace fs = std::filesystem;
using namespace HybridIDE;

// ============================================================================
// ExtensionBuilder Implementation
// ============================================================================

ExtensionBuilder::ExtensionBuilder() {}

ExtensionBuilder::~ExtensionBuilder() {}

bool ExtensionBuilder::createExtension(const std::string& path, const ExtensionConfig& config) {
    try {
        // Create directory structure
        fs::create_directories(path);
        fs::create_directories(path + "/src");
        fs::create_directories(path + "/test");
        fs::create_directories(path + "/.vscode");

        // Generate files
        if (!generatePackageJSON(path, config)) return false;
        if (!generateManifest(path, config)) return false;
        if (!generateActivationCode(path)) return false;

        // Create tsconfig.json
        std::ofstream tsconfig(path + "/tsconfig.json");
        tsconfig << R"({
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2020",
    "outDir": "out",
    "lib": ["ES2020"],
    "sourceMap": true,
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true
  },
  "include": ["src"],
  "exclude": ["node_modules"]
})";
        tsconfig.close();

        // Create README
        std::ofstream readme(path + "/README.md");
        readme << "# " << config.displayName << "\n\n";
        readme << config.description << "\n\n";
        readme << "## Features\n\n";
        readme << "Generated by Hybrid IDE\n";
        readme.close();

        // Create .vscodeignore
        std::ofstream vscodeignore(path + "/.vscodeignore");
        vscodeignore << ".vscode/**\n";
        vscodeignore << ".vscode-test/**\n";
        vscodeignore << "src/**\n";
        vscodeignore << "test/**\n";
        vscodeignore << "**/*.map\n";
        vscodeignore << "**/*.ts\n";
        vscodeignore << "node_modules/**\n";
        vscodeignore.close();

        // Install dependencies
        return installDependencies(path);
    } catch (const std::exception& e) {
        std::cerr << "Error creating extension: " << e.what() << std::endl;
        return false;
    }
}

bool ExtensionBuilder::generatePackageJSON(const std::string& path, const ExtensionConfig& config) {
    std::ofstream file(path + "/package.json");
    if (!file.is_open()) return false;

    file << "{\n";
    file << "  \"name\": \"" << config.name << "\",\n";
    file << "  \"displayName\": \"" << config.displayName << "\",\n";
    file << "  \"description\": \"" << config.description << "\",\n";
    file << "  \"version\": \"" << config.version << "\",\n";
    file << "  \"publisher\": \"" << config.publisher << "\",\n";
    file << "  \"engines\": {\n";
    file << "    \"vscode\": \"^1.85.0\"\n";
    file << "  },\n";
    file << "  \"categories\": [\n";
    for (size_t i = 0; i < config.categories.size(); ++i) {
        file << "    \"" << config.categories[i] << "\"";
        if (i < config.categories.size() - 1) file << ",";
        file << "\n";
    }
    file << "  ],\n";
    file << "  \"activationEvents\": [\"*\"],\n";
    file << "  \"main\": \"./out/extension.js\",\n";
    file << "  \"contributes\": {\n";
    file << "    \"commands\": [\n";
    
    size_t cmdIdx = 0;
    for (const auto& [id, title] : config.commands) {
        file << "      {\n";
        file << "        \"command\": \"" << id << "\",\n";
        file << "        \"title\": \"" << title << "\"\n";
        file << "      }";
        if (++cmdIdx < config.commands.size()) file << ",";
        file << "\n";
    }
    
    file << "    ]\n";
    file << "  },\n";
    file << "  \"scripts\": {\n";
    file << "    \"vscode:prepublish\": \"npm run compile\",\n";
    file << "    \"compile\": \"tsc -p ./\",\n";
    file << "    \"watch\": \"tsc -watch -p ./\",\n";
    file << "    \"package\": \"vsce package\",\n";
    file << "    \"publish\": \"vsce publish\"\n";
    file << "  },\n";
    file << "  \"devDependencies\": {\n";
    file << "    \"@types/vscode\": \"^1.85.0\",\n";
    file << "    \"@types/node\": \"^18.x\",\n";
    file << "    \"typescript\": \"^5.3.0\",\n";
    file << "    \"@vscode/vsce\": \"^2.22.0\"\n";
    file << "  }\n";
    file << "}\n";

    file.close();
    return true;
}

bool ExtensionBuilder::generateManifest(const std::string& path, const ExtensionConfig& config) {
    return true; // Package.json serves as manifest
}

bool ExtensionBuilder::generateActivationCode(const std::string& path) {
    std::ofstream file(path + "/src/extension.ts");
    if (!file.is_open()) return false;

    file << R"(import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    console.log('Extension is now active!');

    // Register commands here
    let disposable = vscode.commands.registerCommand('extension.helloWorld', () => {
        vscode.window.showInformationMessage('Hello from your extension!');
    });

    context.subscriptions.push(disposable);
}

export function deactivate() {}
)";

    file.close();
    return true;
}

bool ExtensionBuilder::build(const std::string& extensionPath, const BuildOptions& options) {
    if (!compile(extensionPath)) {
        std::cerr << "Compilation failed" << std::endl;
        return false;
    }
    
    std::cout << "Extension built successfully" << std::endl;
    return true;
}

bool ExtensionBuilder::compile(const std::string& extensionPath) {
    std::string cmd = "cd " + extensionPath + " && npm run compile";
    int result = system(cmd.c_str());
    return result == 0;
}

bool ExtensionBuilder::package(const std::string& extensionPath) {
    std::string cmd = "cd " + extensionPath + " && npm run package";
    int result = system(cmd.c_str());
    return result == 0;
}

bool ExtensionBuilder::publish(const std::string& extensionPath, const std::string& token) {
    std::string cmd = "cd " + extensionPath + " && vsce publish -p " + token;
    int result = system(cmd.c_str());
    return result == 0;
}

bool ExtensionBuilder::test(const std::string& extensionPath) {
    std::string cmd = "cd " + extensionPath + " && npm test";
    int result = system(cmd.c_str());
    return result == 0;
}

bool ExtensionBuilder::lint(const std::string& extensionPath) {
    std::string cmd = "cd " + extensionPath + " && npm run lint";
    int result = system(cmd.c_str());
    return result == 0;
}

bool ExtensionBuilder::installDependencies(const std::string& path) {
    std::string cmd = "cd " + path + " && npm install";
    int result = system(cmd.c_str());
    return result == 0;
}

bool ExtensionBuilder::runVSCE(const std::string& path, const std::string& command) {
    std::string cmd = "cd " + path + " && vsce " + command;
    int result = system(cmd.c_str());
    return result == 0;
}

std::string ExtensionBuilder::getCommandTemplate() const {
    return R"(
const command = vscode.commands.registerCommand('extension.commandName', () => {
    vscode.window.showInformationMessage('Command executed!');
});
context.subscriptions.push(command);
)";
}

std::string ExtensionBuilder::getWebviewTemplate() const {
    return R"(
const panel = vscode.window.createWebviewPanel(
    'webviewType',
    'Webview Title',
    vscode.ViewColumn.One,
    { enableScripts: true }
);

panel.webview.html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Webview</title>
</head>
<body>
    <h1>Hello from Webview!</h1>
</body>
</html>
`;
)";
}

std::string ExtensionBuilder::getLanguageTemplate() const {
    return R"(
{
  "contributes": {
    "languages": [{
      "id": "mylanguage",
      "extensions": [".mylang"],
      "aliases": ["MyLanguage"],
      "configuration": "./language-configuration.json"
    }],
    "grammars": [{
      "language": "mylanguage",
      "scopeName": "source.mylang",
      "path": "./syntaxes/mylang.tmLanguage.json"
    }]
  }
}
)";
}

std::string ExtensionBuilder::getTreeViewTemplate() const {
    return R"(
class TreeDataProvider implements vscode.TreeDataProvider<TreeItem> {
    getTreeItem(element: TreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: TreeItem): Thenable<TreeItem[]> {
        return Promise.resolve([
            new TreeItem('Item 1'),
            new TreeItem('Item 2')
        ]);
    }
}

class TreeItem extends vscode.TreeItem {
    constructor(public readonly label: string) {
        super(label, vscode.TreeItemCollapsibleState.None);
    }
}

vscode.window.registerTreeDataProvider('myTreeView', new TreeDataProvider());
)";
}

// ============================================================================
// IDEApplication Implementation
// ============================================================================

IDEApplication::IDEApplication() 
    : currentEditor(nullptr), initialized(false) {
    configPath = fs::current_path().string() + "/.hybrid-ide-config.json";
}

IDEApplication::~IDEApplication() {
    shutdown();
}

bool IDEApplication::initialize() {
    if (initialized) return true;

    try {
        // Initialize main window
        IDEWindow::WindowConfig windowConfig;
        windowConfig.title = "Hybrid IDE - Complete Development Environment";
        windowConfig.width = 1920;
        windowConfig.height = 1080;
        mainWindow = std::make_unique<IDEWindow>(windowConfig);

        // Initialize components
        projectExplorer = std::make_unique<ProjectExplorer>();
        debugger = std::make_unique<Debugger>();
        profiler = std::make_unique<Profiler>();
        aiAssistant = std::make_unique<AIAssistant>();
        extensionBuilder = std::make_unique<ExtensionBuilder>();
        cloudSync = std::make_unique<CloudSync>();
        collaboration = std::make_unique<Collaboration>();
        kubernetesManager = std::make_unique<KubernetesManager>();
        compiler = std::make_unique<Compiler>();

        // Load settings
        loadSettings();

        initialized = true;
        std::cout << "Hybrid IDE initialized successfully" << std::endl;
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Failed to initialize IDE: " << e.what() << std::endl;
        return false;
    }
}

int IDEApplication::run() {
    if (!initialized && !initialize()) {
        return 1;
    }

    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                                                            â•‘\n";
    std::cout << "â•‘                     HYBRID IDE v2.0                        â•‘\n";
    std::cout << "â•‘            Complete Development Environment                â•‘\n";
    std::cout << "â•‘                                                            â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    std::cout << "\n";
    std::cout << "Features Available:\n";
    std::cout << "  ðŸŽ¨ Code Editor with Syntax Highlighting\n";
    std::cout << "  ðŸ¤– AI Assistant (GPT-4 & Claude)\n";
    std::cout << "  ðŸ”¨ Multi-Platform Compiler\n";
    std::cout << "  ðŸ› Integrated Debugger\n";
    std::cout << "  âš¡ Performance Profiler\n";
    std::cout << "  ðŸ“¦ VS Code Extension Builder\n";
    std::cout << "  â˜ï¸ Cloud Synchronization\n";
    std::cout << "  ðŸš¢ Kubernetes Integration\n";
    std::cout << "  ðŸ‘¥ Team Collaboration\n";
    std::cout << "\n";

    mainWindow->show();
    mainWindow->run();

    return 0;
}

void IDEApplication::shutdown() {
    if (!initialized) return;

    saveSettings();
    
    // Close all files
    for (auto& editor : editors) {
        if (editor->isModified()) {
            editor->save();
        }
    }
    editors.clear();

    initialized = false;
    std::cout << "Hybrid IDE shutdown complete" << std::endl;
}

IDEWindow* IDEApplication::getMainWindow() {
    return mainWindow.get();
}

EditorTab* IDEApplication::newFile() {
    auto editor = std::make_unique<EditorTab>();
    EditorTab* ptr = editor.get();
    editors.push_back(std::move(editor));
    currentEditor = ptr;
    return ptr;
}

EditorTab* IDEApplication::openFile(const std::string& filePath) {
    // Check if file is already open
    for (auto& editor : editors) {
        if (editor->getFilePath() == filePath) {
            currentEditor = editor.get();
            return editor.get();
        }
    }

    // Open new file
    auto editor = std::make_unique<EditorTab>(filePath);
    if (editor->open(filePath)) {
        EditorTab* ptr = editor.get();
        editors.push_back(std::move(editor));
        currentEditor = ptr;
        return ptr;
    }

    return nullptr;
}

bool IDEApplication::closeFile(EditorTab* tab) {
    auto it = std::find_if(editors.begin(), editors.end(),
        [tab](const std::unique_ptr<EditorTab>& e) { return e.get() == tab; });
    
    if (it != editors.end()) {
        if ((*it)->isModified()) {
            (*it)->save();
        }
        editors.erase(it);
        
        if (currentEditor == tab) {
            currentEditor = editors.empty() ? nullptr : editors.back().get();
        }
        return true;
    }
    return false;
}

std::vector<EditorTab*> IDEApplication::getOpenFiles() const {
    std::vector<EditorTab*> files;
    for (const auto& editor : editors) {
        files.push_back(editor.get());
    }
    return files;
}

EditorTab* IDEApplication::getCurrentEditor() const {
    return currentEditor;
}

bool IDEApplication::openProject(const std::string& projectPath) {
    return projectExplorer->openProject(projectPath);
}

bool IDEApplication::closeProject() {
    return projectExplorer->closeProject();
}

ProjectExplorer* IDEApplication::getProjectExplorer() {
    return projectExplorer.get();
}

Terminal* IDEApplication::createTerminal() {
    auto terminal = std::make_unique<Terminal>();
    Terminal* ptr = terminal.get();
    terminals.push_back(std::move(terminal));
    return ptr;
}

std::vector<Terminal*> IDEApplication::getTerminals() const {
    std::vector<Terminal*> terms;
    for (const auto& terminal : terminals) {
        terms.push_back(terminal.get());
    }
    return terms;
}

bool IDEApplication::build() {
    if (!currentEditor) return false;
    
    std::string filePath = currentEditor->getFilePath();
    if (filePath.empty()) return false;

    CompileOptions options;
    options.sourceFile = filePath;
    return compiler->compile(options, nullptr);
}

bool IDEApplication::buildAndRun() {
    return build();
}

bool IDEApplication::clean() {
    return true;
}

Debugger* IDEApplication::getDebugger() {
    return debugger.get();
}

bool IDEApplication::startDebugging() {
    if (!currentEditor) return false;
    return debugger->start();
}

bool IDEApplication::stopDebugging() {
    return debugger->stop();
}

Profiler* IDEApplication::getProfiler() {
    return profiler.get();
}

bool IDEApplication::profileApplication() {
    return profiler->startProfiling("", Profiler::ProfileType::ALL);
}

AIAssistant* IDEApplication::getAIAssistant() {
    return aiAssistant.get();
}

ExtensionBuilder* IDEApplication::getExtensionBuilder() {
    return extensionBuilder.get();
}

bool IDEApplication::createVSCodeExtension(const std::string& path) {
    ExtensionBuilder::ExtensionConfig config;
    config.name = "my-extension";
    config.displayName = "My Extension";
    config.description = "Generated by Hybrid IDE";
    config.version = "0.0.1";
    config.publisher = "hybrid-ide";
    config.categories = {"Other"};
    
    return extensionBuilder->createExtension(path, config);
}

bool IDEApplication::buildVSCodeExtension(const std::string& path) {
    ExtensionBuilder::BuildOptions options;
    return extensionBuilder->build(path, options);
}

CloudSync* IDEApplication::getCloudSync() {
    return cloudSync.get();
}

bool IDEApplication::syncToCloud() {
    cloudSync->syncUp(projectExplorer->getCurrentProject());
    return true;
}

Collaboration* IDEApplication::getCollaboration() {
    return collaboration.get();
}

bool IDEApplication::startCollabSession() {
    return collaboration->connect("https://collab.hybridide.dev", "");
}

KubernetesManager* IDEApplication::getKubernetesManager() {
    return kubernetesManager.get();
}

bool IDEApplication::deployToKubernetes() {
    return kubernetesManager->initialize();
}

void IDEApplication::loadSettings() {
    if (!fs::exists(configPath)) {
        // Create default settings
        settings["theme"] = "dark";
        settings["fontSize"] = "14";
        settings["tabSize"] = "4";
        settings["autoSave"] = "true";
        saveSettings();
        return;
    }

    std::ifstream file(configPath);
    if (file.is_open()) {
        // Simple key=value parser
        std::string line;
        while (std::getline(file, line)) {
            size_t pos = line.find('=');
            if (pos != std::string::npos) {
                std::string key = line.substr(0, pos);
                std::string value = line.substr(pos + 1);
                settings[key] = value;
            }
        }
        file.close();
    }
}

void IDEApplication::saveSettings() {
    std::ofstream file(configPath);
    if (file.is_open()) {
        for (const auto& [key, value] : settings) {
            file << key << "=" << value << "\n";
        }
        file.close();
    }
}

void IDEApplication::setSetting(const std::string& key, const std::string& value) {
    settings[key] = value;
}

std::string IDEApplication::getSetting(const std::string& key) const {
    auto it = settings.find(key);
    return (it != settings.end()) ? it->second : "";
}
